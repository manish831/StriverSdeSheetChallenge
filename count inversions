// Write your code here.
    /*
    My first approach was to find the index which is just larger than each ith index.
    but its TC was very high....
    #include <bits/stdc++.h> 
long long helper(long long *arr, int s, int e, int &tgt){
    long long mid = e+(s-e)/2;
    if(arr[mid] == tgt){

    }
}
long long getInversions(long long *arr, int n){
    // Write your code here.
    long long ans = 0;
    for(int i=0; i<n-1; i++){
        long long tgt = arr[i];
        int s = i+1, e = n-1;
        
        long long x = helper(arr, s, e, tgt);
        ans += (x-s);
    }
    return ans;
}
    */


#include <bits/stdc++.h> 
long long getInversions(long long *arr, int n){

    int low=0;

    int high=n-1;

    long long cnt=0;

    while(low!=high){

        if(low+1==high){

            if(arr[low]>arr[high]){

                cnt++;

            }

            high=n-1;

            low++;

        }

 

        if(arr[low]>arr[high]){

            cnt++;

            high--;

        }

        else{

            high--;

        }

        

    }

    return cnt;

}
